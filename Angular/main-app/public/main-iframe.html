<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Main Iframe</title>
    <style>
      :root {
        --banner-h: 28px;
        --gap: 12px;
        --border: 1px solid #e5e7eb;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; margin: 0; }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        color: #0f172a;
        background: #fff;
        display: grid;
        grid-template-rows: var(--banner-h) auto 1fr;
        gap: var(--gap);
        padding: var(--gap);
      }

      /* 1) Thin banner across the top */
      .banner {
        grid-row: 1 / 2;
        background: #fef3c7;
        color: #92400e;
        border: var(--border);
        border-radius: 6px;
        display: flex;
        align-items: center;
        padding: 0 10px;
        font-size: 12px;
      }

      /* 2) Single grid row with two cells */
      .two-cell-row {
        grid-row: 2 / 3;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--gap);
        align-items: stretch; /* both cells stretch to the row height, which is set by the tallest */
      }
      .cell {
        border: var(--border);
        border-radius: 6px;
        padding: 12px;
        background: #f8fafc;
        height: 100%; /* ensure cell fills the row height */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* Responsive stacking when too narrow */
      @media (max-width: 800px) {
        .two-cell-row {
          grid-template-columns: 1fr; /* left becomes top, right becomes bottom */
        }
      }

      /* 3) Remaining area split into upper and lower halves */
      .split-vertical {
        grid-row: 3 / 4;
        display: grid;
        grid-template-rows: 1fr 1fr;
        gap: var(--gap);
        min-height: 0; /* allow grid children to shrink */
      }
      .panel {
        border: var(--border);
        border-radius: 6px;
        padding: 12px;
        background: #eef2ff;
        overflow: auto;
      }

      /* 3x3 grid for lower panel */
      .main-grid {
        display: grid;
        grid-template-columns: 2fr 2fr 1fr;
        grid-template-rows: 1fr 1fr 1fr;
        gap: 10px;
        height: 100%;
      }
      .main-grid-cell {
        border: 1px solid #cbd5e1;
        border-radius: 4px;
        background: #f1f5f9;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 13px;
        min-width: 0;
        min-height: 0;
        padding: 6px;
        text-align: center;
      }
      .subgrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        gap: 6px;
        height: 100%;
        width: 100%;
      }
      .subgrid-cell {
        border: 1px solid #e2e8f0;
        border-radius: 3px;
        background: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        min-width: 0;
        min-height: 0;
        padding: 2px;
      }

      .label {
        font-size: 14px;
        line-height: 1.4;
      }
    </style>
  </head>
  <body>
    <!-- Banner -->
    <div class="banner" role="status" aria-live="polite">
      Placeholder: Horizontal thin banner for alert icons (full width at top)
    </div>

    <!-- Two-cell row -->
    <div class="two-cell-row">
      <div class="cell">
        <div class="label">
          Placeholder: Left cell in the single grid row. Height is determined by the tallest of the two cells; width shares available space. When narrow, this cell stacks on top.
        </div>
      </div>
      <div class="cell">
        <div class="label">
          Placeholder: Right cell in the single grid row. Height follows the tallest cell; width shares available space. When narrow, this cell stacks below the left.
        </div>
      </div>
    </div>

    <!-- Remaining split area -->
    <div class="split-vertical">
      <div class="panel">
        <div class="label">Placeholder: Upper half of remaining area.</div>
      </div>
      <div class="panel">
        <div class="main-grid">
          <div class="main-grid-cell" style="grid-column: 1 / span 3; display:flex; gap:8px; align-items:center; justify-content:space-between;">
            <div style="flex:0 0 auto;">WebSocket:</div>
            <input id="wsText" type="text" style="flex:1 1 auto; min-width:0;" placeholder="Type to broadcast..." />
            <span id="wsStatus" style="flex:0 0 auto; font-size:12px; color:#334155;">connecting...</span>
          </div>
           <div class="main-grid-cell">1,1</div>
           <div class="main-grid-cell">1,2</div>
           <div class="main-grid-cell">
            <label for="mainText">Post Message:</label>
             <input id="mainText" type="text" style="width:100%;" autocomplete="off" />
           </div>
           <div class="main-grid-cell">2,1</div>
           <div class="main-grid-cell">2,2</div>
           <div class="main-grid-cell">2,3</div>
           <div class="main-grid-cell">3,1</div>
           <div class="main-grid-cell">3,2</div>
           <div class="main-grid-cell">
             <div class="subgrid">
               <div class="subgrid-cell">A</div>
               <div class="subgrid-cell">B</div>
               <div class="subgrid-cell">C</div>
               <div class="subgrid-cell">D</div>
             </div>
           </div>
         </div>
         <script>
           // Post Message demo
-          const input = document.getElementById('mainText');
-          input.addEventListener('input', () => {
-            window.parent.postMessage({ type: 'sync-text', value: input.value, source: 'main' }, '*');
-          });
-          window.addEventListener('message', (event) => {
-            if (event.data?.type === 'sync-text' && event.data.source !== 'main') {
-              input.value = event.data.value;
-            }
-          });
+          var input = document.getElementById('mainText');
+          input.addEventListener('input', function () {
+            window.parent.postMessage({ type: 'sync-text', value: input.value, source: 'main' }, '*');
+          });
+          window.addEventListener('message', function (event) {
+            var data = event && event.data;
+            if (data && data.type === 'sync-text' && data.source !== 'main') {
+              input.value = data.value;
+            }
+          });
 
           // WebSocket demo
-          let ws;
-          function connect() {
-            try {
-              ws = new WebSocket('ws://localhost:4401');
-              ws.onopen = () => { document.getElementById('wsStatus').textContent = 'connected'; };
-              ws.onclose = () => { document.getElementById('wsStatus').textContent = 'disconnected'; setTimeout(connect, 1000); };
-              ws.onerror = () => { document.getElementById('wsStatus').textContent = 'error'; };
-              ws.onmessage = (ev) => {
-                try {
-                  const msg = JSON.parse(ev.data);
-                  if (msg && msg.type === 'ws-text') {
-                    const field = document.getElementById('wsText');
-                    if (field && document.activeElement !== field) {
-                      field.value = msg.value ?? '';
-                    }
-                  }
-                } catch { /* ignore */ }
-              };
-            } catch {}
-          }
-          connect();
-
-          document.getElementById('wsText').addEventListener('input', (e) => {
-            const value = e.target.value;
-            if (ws && ws.readyState === WebSocket.OPEN) {
-              ws.send(JSON.stringify({ type: 'ws-text', value }));
-            }
-          });
+          var ws;
+          function connect() {
+            try {
+              ws = new WebSocket('ws://localhost:4401');
+              ws.onopen = function () { document.getElementById('wsStatus').textContent = 'connected'; };
+              ws.onclose = function () { document.getElementById('wsStatus').textContent = 'disconnected'; setTimeout(connect, 1000); };
+              ws.onerror = function () { document.getElementById('wsStatus').textContent = 'error'; };
+              ws.onmessage = function (ev) {
+                try {
+                  var msg = JSON.parse(ev.data);
+                  if (msg && msg.type === 'ws-text') {
+                    var field = document.getElementById('wsText');
+                    if (field && document.activeElement !== field) {
+                      field.value = (msg.value != null ? msg.value : '');
+                    }
+                  }
+                } catch (err) { /* ignore */ }
+              };
+            } catch (err) {}
+          }
+          connect();
+
+          document.getElementById('wsText').addEventListener('input', function (e) {
+            var value = e.target && e.target.value;
+            if (ws && ws.readyState === WebSocket.OPEN) {
+              ws.send(JSON.stringify({ type: 'ws-text', value: value }));
+            }
+          });
         </script>
      </div>
    </div>
  </body>
</html>
